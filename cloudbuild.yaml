# Cloud Build configuration for WirePusher CLI
# Triggers:
#   - Push to any branch: Runs tests, quality checks, and build verification
#   - Push tag v*.*.*: Runs full release pipeline with GoReleaser

steps:
  # Step 1: Download dependencies
  - name: 'golang:1.23'
    id: 'download-deps'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Downloading Go dependencies ==="
        go mod download
        echo "✓ Dependencies downloaded"

  # Step 2: Verify dependencies
  - name: 'golang:1.23'
    id: 'verify-deps'
    waitFor: ['download-deps']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Verifying Go dependencies ==="
        go mod verify
        echo "✓ Dependencies verified"

  # Step 3: Format check (gofmt)
  - name: 'golang:1.23'
    id: 'format-check'
    waitFor: ['verify-deps']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Checking code formatting ==="
        UNFORMATTED=$$(gofmt -l .)
        if [ -n "$$UNFORMATTED" ]; then
          echo "❌ The following files are not formatted:"
          echo "$$UNFORMATTED"
          echo ""
          echo "Run 'gofmt -w .' to fix formatting"
          exit 1
        fi
        echo "✓ All files are properly formatted"

  # Step 4: Static analysis (go vet)
  - name: 'golang:1.23'
    id: 'vet'
    waitFor: ['verify-deps']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Running static analysis (go vet) ==="
        go vet ./...
        echo "✓ Static analysis passed"

  # Step 5: Run tests with coverage and race detector
  - name: 'golang:1.23'
    id: 'test'
    waitFor: ['format-check', 'vet']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Running tests with race detector ==="
        go test -race -coverprofile=coverage.out -covermode=atomic -v ./...

        echo ""
        echo "=== Checking test coverage ==="
        go tool cover -func=coverage.out | tail -10

        COV=$(go tool cover -func=coverage.out | grep total | awk '{print $$3}' | sed 's/%//')
        echo ""
        echo "Total coverage: $${COV}%"

        # Enforce 30% minimum coverage for overall project
        # Note: cmd layer has no tests (Cobra CLI wiring), which reduces total coverage.
        # The pkg/ layer has ~61% coverage (validation: 100%, crypto: 88%, config: 71%).
        # Consider adding cmd layer tests to increase coverage.
        if [ $$(echo "$$COV < 30" | bc) -eq 1 ]; then
          echo "❌ Coverage $${COV}% is below 30% threshold"
          exit 1
        fi
        echo "✓ Coverage meets 30% threshold"

        # Also check pkg layer coverage separately (higher standard)
        echo ""
        echo "=== Checking pkg layer coverage ==="
        go test -coverprofile=pkg_coverage.out ./pkg/...
        PKG_COV=$(go tool cover -func=pkg_coverage.out | grep total | awk '{print $$3}' | sed 's/%//')
        echo "Pkg layer coverage: $${PKG_COV}%"

        if [ $$(echo "$$PKG_COV < 55" | bc) -eq 1 ]; then
          echo "❌ Pkg coverage $${PKG_COV}% is below 55% threshold"
          exit 1
        fi
        echo "✓ Pkg layer coverage meets 55% threshold"

  # Step 6: Build verification (all platforms)
  - name: 'golang:1.23'
    id: 'build'
    waitFor: ['test']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Verifying builds for all platforms ==="

        echo "Building linux/amd64..."
        GOOS=linux GOARCH=amd64 go build -o /dev/null .
        echo "✓ linux/amd64"

        echo "Building linux/arm64..."
        GOOS=linux GOARCH=arm64 go build -o /dev/null .
        echo "✓ linux/arm64"

        echo "Building linux/arm (v7)..."
        GOOS=linux GOARCH=arm GOARM=7 go build -o /dev/null .
        echo "✓ linux/arm"

        echo "Building darwin/amd64..."
        GOOS=darwin GOARCH=amd64 go build -o /dev/null .
        echo "✓ darwin/amd64"

        echo "Building darwin/arm64..."
        GOOS=darwin GOARCH=arm64 go build -o /dev/null .
        echo "✓ darwin/arm64"

        echo "Building windows/amd64..."
        GOOS=windows GOARCH=amd64 go build -o /dev/null .
        echo "✓ windows/amd64"

        echo "Building windows/arm64..."
        GOOS=windows GOARCH=arm64 go build -o /dev/null .
        echo "✓ windows/arm64"

        echo ""
        echo "✓ All platform builds verified"

  # Step 7: Release with GoReleaser (only on tags)
  - name: 'goreleaser/goreleaser:v2.5.1'
    id: 'release'
    waitFor: ['build']
    entrypoint: 'bash'
    secretEnv: ['GITLAB_TOKEN']
    args:
      - '-c'
      - |
        if [ -z "$TAG_NAME" ]; then
          echo "=== No Git tag detected ==="
          echo "Skipping release step (only runs on tags)"
          exit 0
        fi

        echo "=== Git tag detected: $TAG_NAME ==="

        # Validate semantic version format
        if ! echo "$TAG_NAME" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+'; then
          echo "❌ Invalid tag format: $TAG_NAME"
          echo "Expected format: v{major}.{minor}.{patch} (e.g., v1.0.0)"
          exit 1
        fi
        echo "✓ Tag format valid"

        # Verify required files exist
        echo ""
        echo "=== Verifying required files ==="
        test -f go.mod && echo "✓ go.mod exists" || (echo "❌ go.mod missing" && exit 1)
        test -f go.sum && echo "✓ go.sum exists" || (echo "❌ go.sum missing" && exit 1)
        test -f README.md && echo "✓ README.md exists" || (echo "❌ README.md missing" && exit 1)
        test -f LICENSE && echo "✓ LICENSE exists" || (echo "❌ LICENSE missing" && exit 1)
        test -f CHANGELOG.md && echo "✓ CHANGELOG.md exists" || (echo "❌ CHANGELOG.md missing" && exit 1)
        test -f .goreleaser.yml && echo "✓ .goreleaser.yml exists" || (echo "❌ .goreleaser.yml missing" && exit 1)

        echo ""
        echo "=== Running GoReleaser ==="
        export GITLAB_TOKEN="$$GITLAB_TOKEN"
        goreleaser release --clean

        echo ""
        echo "✓ Release $TAG_NAME published successfully to GitLab"

  # Step 8: Send notification on successful release (only on tags)
  - name: 'curlimages/curl:latest'
    id: 'notify-release'
    waitFor: ['release']
    entrypoint: 'sh'
    secretEnv: ['WIREPUSHER_TOKEN']
    args:
      - '-c'
      - |
        if [ -z "$TAG_NAME" ]; then
          echo "=== No Git tag detected ==="
          echo "Skipping notification (only runs on tags)"
          exit 0
        fi

        echo "=== Sending release notification via NotifAI ==="
        curl -s -X POST https://api.wirepusher.dev/notifai \
          -H "Authorization: Bearer $$WIREPUSHER_TOKEN" \
          -H "Content-Type: application/json" \
          -d "{
            \"text\": \"WirePusher CLI $TAG_NAME released successfully to GitLab. 7 platform binaries available for download. Install via curl -sSL install script or download from https://gitlab.com/wirepusher/wirepusher-cli/-/releases/$TAG_NAME\"
          }"

        echo ""
        echo "✓ Release notification sent via NotifAI"

# Secrets for GitLab release and notifications
availableSecrets:
  secretManager:
    - versionName: projects/$PROJECT_ID/secrets/gitlab-api-token-cloudbuild/versions/latest
      env: 'GITLAB_TOKEN'
    - versionName: projects/$PROJECT_ID/secrets/wirepusher-token/versions/latest
      env: 'WIREPUSHER_TOKEN'

# Build options
options:
  machineType: 'E2_HIGHCPU_8'
  logging: CLOUD_LOGGING_ONLY

# Build timeout (10 minutes)
timeout: '600s'

# Artifacts to store in GCS
artifacts:
  objects:
    location: 'gs://${PROJECT_ID}_cloudbuild/artifacts/cli/${BUILD_ID}'
    paths:
      - 'coverage.out'
      - 'go.mod'
      - 'README.md'
